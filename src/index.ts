import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import tmp from "tmp";
import {
  type InterfaceDeclaration,
  ModuleKind,
  Node,
  Project,
  ScriptTarget,
  type SourceFile,
  SyntaxKind,
} from "ts-morph";

/**
 * Generates a TypeScript API client using openapi-fetch based on TypeScript interface definitions
 * generated by openapi-typescript.
 */
export function generateClient(
  schemaFilePath: string,
  options: { useOperationId?: boolean } = {},
): string {
  const project = new Project({
    compilerOptions: {
      target: ScriptTarget.Latest,
      module: ModuleKind.ESNext,
    },
  });
  const schemaFile = project.addSourceFileAtPath(schemaFilePath);

  const pathsInterface = findInterface(schemaFile, "paths");
  if (!pathsInterface) {
    throw new Error(`Interface "paths" not found in ${schemaFilePath}`);
  }
  const componentsInterface = findInterface(schemaFile, "components");

  return generateClientCode(
    pathsInterface,
    componentsInterface,
    path.basename(schemaFilePath),
    options,
  );
}

function findInterface(
  sourceFile: SourceFile,
  interfaceName: string,
): InterfaceDeclaration | undefined {
  return sourceFile.getInterfaces().find((i) => i.getName() === interfaceName);
}

interface EndpointInfo {
  path: string;
  httpMethod: string;
  operationName: string;
  operationId: string | null;
  commentLines: string[];
  paramsType: string | null;
  bodyType: string | null;
  bodyContentType: string | null;
  headerType: string | null;
}

function generateClientCode(
  pathsInterface: InterfaceDeclaration,
  componentsInterface: InterfaceDeclaration | undefined,
  schemaFileName: string,
  options: { useOperationId?: boolean } = {},
): string {
  const endpoints = extractEndpointsInfo(pathsInterface);

  const clientClass = generateClientClass(endpoints, options);

  const code = [
    "// THIS FILE IS AUTO-GENERATED BY openapi-fetch-gen.",
    "// DO NOT EDIT THIS FILE MANUALLY.",
    "// See Also: https://github.com/moznion/openapi-fetch-gen",
    `import createClient, { type ClientOptions } from "openapi-fetch";`,
    `import type { components, paths } from "./${schemaFileName}"; // generated by openapi-typescript`,
    "",
    clientClass,
    "",
    ...generateSchemaTypes(componentsInterface),
  ].join("\n");

  const tempFile = tmp.fileSync({ postfix: ".ts" }).name;
  fs.writeFileSync(tempFile, code);
  execSync(`npx biome check --write ${tempFile}`);
  return fs.readFileSync(tempFile, "utf-8");
}

function generateSchemaTypes(
  componentsInterface: InterfaceDeclaration | undefined,
): string[] {
  const schemasProperty = componentsInterface?.getProperty("schemas");

  const types = [];
  if (schemasProperty) {
    const schemasType = schemasProperty.getType();
    for (const schema of schemasType.getProperties()) {
      const schemaType = schema.getValueDeclaration()?.getType();
      if (schemaType) {
        const schemaName = schema.getName();
        const schemaTypeName = (
          schemaName + (schemaName === "Client" ? "Schema" : "")
        ).replaceAll(/-/g, "_");
        types.push(
          `export type ${schemaTypeName} = components["schemas"]["${schema.getName()}"];`,
        );
      }
    }
  }

  return types;
}

function extractEndpointsInfo(
  pathsInterface: InterfaceDeclaration,
): EndpointInfo[] {
  const endpoints: EndpointInfo[] = [];

  for (const property of pathsInterface.getProperties()) {
    const path = property.getName().replace(/['"]/g, "");
    const propertyType = property.getType();

    const httpMethods = [
      "get",
      "post",
      "put",
      "delete",
      "patch",
      "head",
      "options",
    ];

    for (const httpMethod of httpMethods) {
      // Get the operation type
      const methodProperty = propertyType.getProperty(httpMethod);
      if (!methodProperty) {
        continue;
      }
      if (methodProperty.getTypeAtLocation(property).getText() === "never") {
        continue;
      }

      const commentLines: string[] = [];
      let paramsType: string | null = null;
      let requestBodyType: string | null = null;

      const declarations = methodProperty.getDeclarations();
      if (declarations.length <= 0) {
        continue;
      }
      const decl = declarations[0];

      if (!Node.isPropertySignature(decl)) {
        continue;
      }

      const typeNode = decl.getTypeNodeOrThrow();

      const operationId = (() => {
        if (
          Node.isIndexedAccessTypeNode(typeNode) &&
          typeNode.getObjectTypeNode().getText() === "operations"
        ) {
          const indexTypeNode = typeNode.getIndexTypeNode();
          if (
            Node.isLiteralTypeNode(indexTypeNode) &&
            indexTypeNode.getLiteral().getKind() === SyntaxKind.StringLiteral
          ) {
            return sanitizeForOperation(
              indexTypeNode.getLiteral().getText().slice(1, -1),
            );
          }
        }
        return null;
      })();

      const paramProp = decl.getType().getPropertyOrThrow("parameters");
      const paramTypes = paramProp
        .getTypeAtLocation(decl)
        .getProperties()
        .map((prop) => {
          const propType = prop.getTypeAtLocation(decl);
          const text = propType.getText();
          const name = prop.getName();
          if (text === "never") {
            return { name, text: "" };
          }
          return { name, text };
        })
        .filter((kv) => kv["text"] !== "");

      const headerType = paramTypes.find((kv) => kv.name === "header");
      if (headerType) {
        // header exists in params
        const nonHeaderParams = paramTypes
          .filter((kv) => kv.name !== "header")
          .map((kv) => `${kv.name}: ${kv.text}`)
          .join("\n");

        paramsType =
          `[
  Exclude< // Missed Header Keys for default headers
    keyof ${headerType["text"]},
    Extract< // Provided header keys by default headers' keys
      keyof HT, keyof ${headerType["text"]}
    >
  >,
] extends [never] ? ` +
          // When the default headers cover all the headers (i.e. `Exclude<...>` derived as `never`),
          // header parameter becomes optional (omitting or )overriding default headers.
          `{
    header?: ${headerType["text"]},
    ${nonHeaderParams}
  } : ` + // Else, header parameter is required as either follows:
          // 1. requires sorely missed header values
          // 2. requires all the header values (overriding default headers)
          `{
    header:
      | (Pick< // Pick the header keys that are not in the default headers
          ${headerType["text"]},
          Exclude< // Missed Header Keys for default headers
            keyof ${headerType["text"]},
            Extract< // Provided header keys by default headers' keys
              keyof HT, keyof ${headerType["text"]}
            >
          >
        > &
        Partial< // Disallow default headers' keys to be in the header param
          Record<
            Extract< // Provided header keys by default headers' keys
              keyof HT, keyof ${headerType["text"]}
            >,
            never
          >
        >)
      | ${headerType["text"]},
    ${nonHeaderParams}
}
`;
      } else {
        const params = paramTypes
          .map((kv) => `${kv.name}: ${kv.text}`)
          .join("\n");
        if (params !== "") {
          paramsType = `{${params}}`;
        }
      }

      const requestBodyProp = decl.getType().getProperty("requestBody");
      let requestBodyContentType: string | null = null;
      if (requestBodyProp) {
        const t = requestBodyProp.getTypeAtLocation(decl);
        if (t.getText() !== "never") {
          const contentProp = t.getPropertyOrThrow("content");
          const contentType = contentProp.getTypeAtLocation(decl);
          const contentTypeProps = contentType.getProperties();

          if (contentTypeProps.length > 0 && contentTypeProps[0]) {
            requestBodyContentType =
              contentType.getProperties()?.[0]?.getName() || null;
            requestBodyType = contentTypeProps[0]
              .getTypeAtLocation(decl)
              .getText();
          }
        }
      }

      if ("getJsDocs" in decl && typeof decl.getJsDocs === "function") {
        const jsDocs = decl.getJsDocs();
        for (const d of jsDocs) {
          const description = d.getDescription().trim();
          if (description) {
            commentLines.push(`* ${description}`);
          }
        }
      }

      const sanitizedPath = sanitizeForOperation(path);

      // Generate a camelCase operation name
      const pathSegments = sanitizedPath.split("_");
      const camelCasePath = pathSegments
        .map((segment, index) => {
          // First segment is lowercase, rest are capitalized
          if (index === 0) return segment.toLowerCase();
          return (
            segment.charAt(0).toUpperCase() + segment.slice(1).toLowerCase()
          );
        })
        .join("");

      const defaultOperationName = `${httpMethod}${camelCasePath
        .charAt(0)
        .toUpperCase()}${camelCasePath.slice(1)}`;

      endpoints.push({
        path,
        httpMethod,
        operationName: defaultOperationName,
        operationId,
        commentLines,
        paramsType,
        bodyType: requestBodyType,
        bodyContentType: requestBodyContentType,
        headerType: headerType ? headerType["text"] : null,
      });
    }
  }

  return endpoints;
}

function generateClientClass(
  endpoints: EndpointInfo[],
  options: { useOperationId?: boolean } = {},
): string {
  const classCode = [
    `export class Client<HT extends Record<string, string>> {
       readonly client;
       defaultHeaders: HT;

       constructor(clientOptions: ClientOptions, defaultHeaders?: HT) {
         this.client = createClient<paths>(clientOptions);
         this.defaultHeaders = defaultHeaders ?? ({} as HT);
       }
    `,
  ];

  // Generate class methods for each endpoint
  for (const endpoint of endpoints) {
    const {
      path,
      httpMethod,
      operationName,
      operationId,
      commentLines,
      paramsType,
      bodyType,
      bodyContentType,
    } = endpoint;

    const methodName =
      options.useOperationId && operationId ? operationId : operationName;

    // Add JSDoc comment if available
    if (commentLines.length > 0) {
      classCode.push("    /**");
      for (const line of commentLines) {
        classCode.push(`     ${line}`);
      }
      classCode.push("     */");
    }

    // Method signature
    classCode.push(`    async ${methodName}(`);

    // Add method parameters with proper indentation
    const paramsList = [];
    if (paramsType) {
      paramsList.push(`params: ${paramsType}`);
    }

    if (bodyType) {
      // Properly indent the body by ensuring it starts with correct indentation
      paramsList.push(`body: ${bodyType}`);
    }

    if (paramsList.length > 0) {
      classCode.push(paramsList.join(",\n"));
    }

    classCode.push("    ) {");

    // Method body
    classCode.push(
      `        return await this.client.${httpMethod.toUpperCase()}("${path}", {`,
    );

    if (paramsType) {
      if (endpoint.headerType) {
        const contentTypeHeader = bodyContentType
          ? `, "Content-Type": "${bodyContentType}"`
          : "";
        classCode.push(`params: {
  ...params,
  header: {...this.defaultHeaders, ...params.header${contentTypeHeader}} as ${endpoint.headerType},
},`);
      } else {
        classCode.push("params,");
      }
    }

    if (bodyType) {
      classCode.push("            body,");
    }

    classCode.push("        });");
    classCode.push("    }");
    classCode.push("");
  }

  classCode.push("}");
  classCode.push("");

  return classCode.join("\n");
}

function sanitizeForOperation(operation: string): string {
  return operation
    .replace(/[{}]/g, "")
    .replace(/[-/.]/g, "_")
    .replace(/^_/, ""); // Remove leading underscore if present
}
