import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import tmp from "tmp";
import {
  type InterfaceDeclaration,
  ModuleKind,
  Project,
  ScriptTarget,
} from "ts-morph";
import { type Endpoint, extractEndpointsInfo } from "./endpoint";
import { findInterface, throwError } from "./utils";

/**
 * Generates a TypeScript API client using openapi-fetch based on TypeScript interface definitions
 * generated by openapi-typescript.
 */
export function genClient(
  pathSchema: string,
  opts: { useOperationId?: boolean; schemaImportPathPrefix?: string } = {},
): string {
  const project = new Project({
    compilerOptions: {
      target: ScriptTarget.Latest,
      module: ModuleKind.ESNext,
    },
  });
  const f = project.addSourceFileAtPath(pathSchema);

  const code = `
// THIS FILE IS AUTO-GENERATED BY openapi-fetch-gen.
// DO NOT EDIT THIS FILE MANUALLY.
// See Also: https://github.com/moznion/openapi-fetch-gen
import createClient, { type ClientOptions, Client as ClientOap } from "openapi-fetch";
import type { components, paths } from "${
    !opts.schemaImportPathPrefix
      ? `./${path.basename(pathSchema)}`
      : `${opts.schemaImportPathPrefix}${path.basename(pathSchema)}`
  }"; // generated by openapi-typescript

${genClientClassCode(
  extractEndpointsInfo(
    findInterface(f, "paths") ??
      throwError(`Interface "paths" not found in ${pathSchema}`),
  ),
  opts,
)}

${genSchemaTypesCode(findInterface(f, "components"))}
`;

  const fTmp = tmp.fileSync({ postfix: ".ts" }).name;
  fs.writeFileSync(fTmp, code);
  execSync(`npx biome check --write ${fTmp}`);

  return fs.readFileSync(fTmp, "utf-8");
}

function genClientClassCode(
  eps: Endpoint[],
  opts: { useOperationId?: boolean } = {},
): string {
  const c = eps
    .map((ep) => {
      const headerContentType = ep.bodyContentType
        ? `"Content-Type": "${ep.bodyContentType}", `
        : "";
      const paramsEach = Object.entries({
        header: ep.headerType
          ? `{${headerContentType}...this.defaultHeaders, ...opts.header} as ${ep.headerType}`
          : "",
        path: ep.pathType ? "opts.path" : "",
        query: ep.queryType ? "opts.query" : "",
      })
        .filter((kv) => kv[1] !== "")
        .map((kv) => `${kv[0]}: ${kv[1]}`)
        .join(",\n                ");
      const params = [
        paramsEach
          ? `params: {\n                ${paramsEach}\n            }`
          : "",
        ep.bodyType ? "body: opts.body" : "",
      ]
        .filter((v) => v !== "")
        .join(",\n            ");

      return `\n
    async ${opts.useOperationId && ep.opId ? ep.opId : ep.opName}(${
      ep.optsType ? `\n       opts: ${ep.optsType}    ) {` : ") {"
    }
        return await this.client.${ep.method.toUpperCase()}("${ep.path}", ${
          params ? `{\n            ${params}\n        });` : "{});"
        }
    }`;
    })
    .join("");

  return `
export class Client<HT extends Record<string, string>> {
    readonly client: ClientOap<paths>;
    defaultHeaders: HT;

    constructor(clientOptions: ClientOptions, defaultHeaders?: HT) {
        this.client = createClient<paths>(clientOptions);
        this.defaultHeaders = defaultHeaders ?? ({} as HT);
    }${c}
}
`.slice(1);
}

function genSchemaTypesCode(
  componentsIf: InterfaceDeclaration | undefined,
): string {
  return `
${
  componentsIf
    ?.getProperty("schemas")
    ?.getType()
    .getProperties()
    .map((schema) => {
      if (!schema.getValueDeclaration()?.getType()) {
        return "";
      }

      const schemaName = schema.getName();
      const schemaTypeName = `${schemaName}${
        schemaName === "Client" ? "Schema" : ""
      }`.replaceAll(/-/g, "_");

      return `export type ${schemaTypeName} = components["schemas"]["${schema.getName()}"];`;
    })
    .join("\n") ?? ""
}
`.slice(1, -1);
}
