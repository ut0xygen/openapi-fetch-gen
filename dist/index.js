"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.genClient = genClient;
const node_child_process_1 = require("node:child_process");
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const tmp_1 = __importDefault(require("tmp"));
const ts_morph_1 = require("ts-morph");
const endpoint_1 = require("./endpoint");
const utils_1 = require("./utils");
function genClient(schemaFilePath, options = {}) {
    const project = new ts_morph_1.Project({
        compilerOptions: {
            target: ts_morph_1.ScriptTarget.Latest,
            module: ts_morph_1.ModuleKind.ESNext,
        },
    });
    const schemaFile = project.addSourceFileAtPath(schemaFilePath);
    const code = `
// THIS FILE IS AUTO-GENERATED BY openapi-fetch-gen.
// DO NOT EDIT THIS FILE MANUALLY.
// See Also: https://github.com/moznion/openapi-fetch-gen
import createClient, { type ClientOptions, Client as ClientOap } from "openapi-fetch";
import type { components, paths } from "./${node_path_1.default.basename(schemaFilePath)}"; // generated by openapi-typescript

${genClientClassCode((0, endpoint_1.extractEndpointsInfo)((0, utils_1.findInterface)(schemaFile, "paths") ??
        (0, utils_1.throwError)(`Interface "paths" not found in ${schemaFilePath}`)), options)}

${genSchemaTypesCode((0, utils_1.findInterface)(schemaFile, "components"))}
`;
    const tempFile = tmp_1.default.fileSync({ postfix: ".ts" }).name;
    node_fs_1.default.writeFileSync(tempFile, code);
    (0, node_child_process_1.execSync)(`npx biome check --write ${tempFile}`);
    return node_fs_1.default.readFileSync(tempFile, "utf-8");
}
function genClientClassCode(eps, opts = {}) {
    const codeMethods = eps
        .map((ep) => {
        const codeHeaderContentType = ep.bodyContentType
            ? `"Content-Type": "${ep.bodyContentType}", `
            : "";
        const codeParamsEach = Object.entries({
            header: ep.headerType
                ? `{${codeHeaderContentType}...this.defaultHeaders, ...opts.header} as ${ep.headerType}`
                : "",
            path: ep.pathType ? "opts.path" : "",
            query: ep.queryType ? "opts.query" : "",
        })
            .filter((kv) => kv[1] !== "")
            .map((kv) => `${kv[0]}: ${kv[1]}`)
            .join(",\n                ");
        const codeParams = [
            codeParamsEach
                ? `params: {\n                ${codeParamsEach}\n            }`
                : "",
            ep.bodyType ? "body: opts.body" : "",
        ]
            .filter((v) => v !== "")
            .join(",\n            ");
        return `\n
    async ${opts.useOperationId && ep.opId ? ep.opId : ep.opName}(${ep.optsType ? `\n       opts: ${ep.optsType}    ) {` : ") {"}
        return await this.client.${ep.method.toUpperCase()}("${ep.path}", ${codeParams ? `{\n            ${codeParams}\n        });` : "{});"}
    }`;
    })
        .join("");
    return `
export class Client<HT extends Record<string, string>> {
    readonly client: ClientOap<paths>;
    defaultHeaders: HT;

    constructor(clientOptions: ClientOptions, defaultHeaders?: HT) {
        this.client = createClient<paths>(clientOptions);
        this.defaultHeaders = defaultHeaders ?? ({} as HT);
    }${codeMethods}
}
`.slice(1);
}
function genSchemaTypesCode(componentsIf) {
    return `
${componentsIf
        ?.getProperty("schemas")
        ?.getType()
        .getProperties()
        .map((schema) => {
        if (!schema.getValueDeclaration()?.getType()) {
            return "";
        }
        const schemaName = schema.getName();
        const schemaTypeName = `${schemaName}${schemaName === "Client" ? "Schema" : ""}`.replaceAll(/-/g, "_");
        return `export type ${schemaTypeName} = components["schemas"]["${schema.getName()}"];`;
    })
        .join("\n") ?? ""}
`.slice(1, -1);
}
//# sourceMappingURL=index.js.map